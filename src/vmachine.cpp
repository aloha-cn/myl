
/* vmachine.cpp - A simple vmachine to run code generated by MYL
 *
 * Copyright (c) 2019 Eric Wan <aloha_cn@hotmail.com>
 *
 * This file is part of MYL.
 *
 * MYL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "vmachine.h"

int SP, IP;
Instruction VMCode[CODESIZE];
MemUnit VMStack[STACKSIZE];

static	void MemCopy(int src, int dest);

static const char *opname[]={
	"MOV", "ADD", "SUB", "MUL", "DIV", "MOD", "OR",  "AND", "XOR",
	"NOTEQU", "EQU", "LESS", "LE", "GREAT",	"GE",
	"PUSH","POP", "JMP", "CALL","RET",
	"JE",  "JG",  "JL", "SHL", "SHR", "NOT", "INC", "DEC",
	"JNE", "CNV",
	};

void VMError(int lineno, const char *msg)
{
	fprintf (stderr, "VM error@(%d):%s\n",lineno,msg);
	exit(0);
}

static void MemCopy(int src, int dest)
{
	if (VMStack[src].tag==T_STRING) {
		PrepareMem(dest);
		*VMMEM(dest).str=*VMMEM(src).str;
	}
	else {
		VMStack[dest]=VMStack[src];
	}
}

void PrintDisasm(FILE *fp, int addr, const Instruction *code)
{
	const char *fmt_int="0x%X", *fmt_float="%g";

	fprintf (fp,"[%4.4X]", addr);
	if (code->op&FLFLAG) fprintf(fp,"F");
	if (code->op&STRFLAG) fprintf(fp,"S");
	fprintf(fp,"%s ", opname[code->op & OPMASK]);

	if (!(code->op & FLAG1)) {
		fprintf (fp,"(%X", code->src1.i);
	}
	else if (code->op&FLFLAG) {
		fprintf (fp, fmt_float, code->src1.f);
	}
	else {
		fprintf (fp, fmt_int, code->src1.i);
	}
	if (!(code->op & FLAG1)) fprintf (fp,") ");
	else fprintf(fp, " ");
	if (!(code->op & FLAG2)) {
		fprintf(fp,"(%X", code->src2.i);
	}
	else if (code->op&FLFLAG) {
		fprintf (fp,fmt_float,code->src2.f);
	}
	else {
		fprintf (fp,fmt_int, code->src2.i);
	}
	if (!(code->op & FLAG2)) fprintf (fp, ") ");
	else fprintf (fp," ");
	if (!(code->op & FLAG3)) fprintf (fp,"(%X)\n", code->dest);
	else fprintf (fp, "0x%X\n", code->dest);
}

void PrepareInt(int op, int *psrc1, int *psrc2)
{
	if (op & FLAG1) *psrc1=VMCode[IP].src1.i;
	else *psrc1=GetMemInt(VMCode[IP].src1.i);
	if (op & FLAG2) *psrc2=VMCode[IP].src2.i;
	else *psrc2=GetMemInt(VMCode[IP].src2.i);
}

void PrepareFloat(int op, float *psrc1, float *psrc2)
{
	if (op & FLAG1) *psrc1 = VMCode[IP].src1.f;
	else *psrc1 = GetMemFloat(VMCode[IP].src1.i);
	if (op & FLAG2) *psrc2=VMCode[IP].src2.f;
	else *psrc2 = GetMemFloat(VMCode[IP].src2.i);
}

void Run(int addr)
{
	IP=addr;
	while (Step());
}

void PrepareMem(int addr)
{
	if (VMStack[addr].tag!=T_STRING) {
		VMStack[addr].tag = T_STRING;
		VMMEM(addr).str = new StringType;
	}
}

void DestroyMem(int addr)
{
	if (VMStack[addr].tag==T_STRING && VMMEM(addr).str) {
		delete VMMEM(addr).str;
		VMMEM(addr).str=0;
	}
	VMStack[addr].tag=T_NULL;
}

float GetMemFloat(int addr)
{
	switch (VMStack[addr].tag) {
	case T_INTEGER:
		return (float)VMMEM(addr).i;
	case T_FLOAT:
		return VMMEM(addr).f;
	case T_STRING:
		return (float)atof(VMMEM(addr).str->c_str());
	case T_NULL:
	default:
		VMError(__LINE__, "Access violation.");
		return 0.0;
	}
}

int GetMemInt(int addr)
{
	switch (VMStack[addr].tag) {
	case T_INTEGER:
		return VMMEM(addr).i;
	case T_FLOAT:
		return (int)VMMEM(addr).f;
	case T_STRING:
		return atoi(VMMEM(addr).str->c_str());
	case T_NULL:
	default:
		VMError(__LINE__, "Access violation.");
		return INT_MAX;
	}
}

void SetMemFloat(int addr, float num)
{
	if (VMStack[addr].tag==T_STRING)
		DestroyMem(addr);
	VMStack[addr].tag=T_FLOAT;
	VMMEM(addr).f=num;
}

void SetMemInt(int addr, int num)
{
	if (VMStack[addr].tag==T_STRING)
		DestroyMem(addr);
	VMStack[addr].tag=T_INTEGER;
	VMMEM(addr).i=num;
}

void SetMemStr(int addr, const StringType &str)
{
	if (VMStack[addr].tag!=T_STRING)
		PrepareMem(addr);
	VMStack[addr].tag=T_STRING;
	*VMMEM(addr).str=str;
}

int Step()
{
	float srcfloat1, srcfloat2;
	int srcint1, srcint2;
	switch (VMCode[IP].op & OPMASK) {
	case MOV:
		if (VMCode[IP].op & FLAG1)
			if (VMCode[IP].op&FLFLAG)
				SetMemFloat(VMCode[IP].dest, VMCode[IP].src1.f);
			else
				SetMemInt(VMCode[IP].dest, VMCode[IP].src1.i);
		else MemCopy(VMCode[IP].src1.i,VMCode[IP].dest);
		IP++;
		break;
	case ADD:
		if (VMCode[IP].op&FLFLAG) {
			PrepareFloat(VMCode[IP].op, &srcfloat1, &srcfloat2);
			SetMemFloat(VMCode[IP].dest, srcfloat1+srcfloat2);
		}
		else {
			PrepareInt(VMCode[IP].op, &srcint1, &srcint2);
			SetMemInt(VMCode[IP].dest, srcint1+srcint2);
		}
		IP++;
		break;
	case SUB:
		if (VMCode[IP].op&FLFLAG) {
			PrepareFloat(VMCode[IP].op, &srcfloat1, &srcfloat2);
			SetMemFloat(VMCode[IP].dest, srcfloat1-srcfloat2);
		}
		else {
			PrepareInt(VMCode[IP].op, &srcint1, &srcint2);
			SetMemInt(VMCode[IP].dest, srcint1-srcint2);
		}
		IP++;
		break;
	case MUL:
		if (VMCode[IP].op&FLFLAG) {
			PrepareFloat(VMCode[IP].op, &srcfloat1, &srcfloat2);
			SetMemFloat(VMCode[IP].dest, srcfloat1*srcfloat2);
		}
		else {
			PrepareInt(VMCode[IP].op, &srcint1, &srcint2);
			SetMemInt(VMCode[IP].dest, srcint1*srcint2);
		}
		IP++;
		break;
	case DIV:
		if (VMCode[IP].op&FLFLAG) {
			PrepareFloat(VMCode[IP].op, &srcfloat1, &srcfloat2);
			if(srcfloat2==0)
				VMError(__LINE__,"Math Error");
			SetMemFloat(VMCode[IP].dest, srcfloat1/srcfloat2);
		}
		else {
			PrepareInt(VMCode[IP].op, &srcint1, &srcint2);
			if(srcint2==0)
				VMError(__LINE__,"Math Error");
			SetMemInt(VMCode[IP].dest, srcint1/srcint2);
		}
		IP++;
		break;
	case MOD:
		if (VMCode[IP].op&FLFLAG) {
			PrepareFloat(VMCode[IP].op, &srcfloat1, &srcfloat2);
			if(srcfloat2==0)
				VMError(__LINE__,"Math Error/n");
			SetMemFloat(VMCode[IP].dest, (float)fmod(srcfloat1,srcfloat2));
		}
		else {
			PrepareInt(VMCode[IP].op, &srcint1, &srcint2);
			if(srcint2==0)
				VMError(__LINE__,"Math Error/n");
			SetMemInt(VMCode[IP].dest, srcint1%srcint2);
		}
		IP++;
		break;
	case SHL:
		if (VMCode[IP].op&FLFLAG) {
			VMError(__LINE__, "SHL use float");
		}
		else {
			PrepareInt(VMCode[IP].op, &srcint1, &srcint2);
			SetMemInt(VMCode[IP].dest, srcint1<<srcint2);
		}
		IP++;
		break;
	case SHR:
		if (VMCode[IP].op&FLFLAG) {
			VMError(__LINE__, "SHR use float");
		}
		else {
			PrepareInt(VMCode[IP].op, &srcint1, &srcint2);
			SetMemInt(VMCode[IP].dest, srcint1>>srcint2);
		}
		IP++;
		break;
	case OR:
		if (VMCode[IP].op&FLFLAG) {
			VMError(__LINE__, "OR use float");
		}
		else {
			PrepareInt(VMCode[IP].op, &srcint1, &srcint2);
			SetMemInt(VMCode[IP].dest, srcint1|srcint2);
		}
		IP++;
		break;
	case AND:
		if (VMCode[IP].op&FLFLAG) {
			VMError(__LINE__, "AND use float");
		}
		else {
			PrepareInt(VMCode[IP].op, &srcint1, &srcint2);
			SetMemInt(VMCode[IP].dest, srcint1&srcint2);
		}
		IP++;
		break;
	case XOR:
		if (VMCode[IP].op&FLFLAG) {
			VMError(__LINE__, "XOR use float");
		}
		else {
			PrepareInt(VMCode[IP].op, &srcint1, &srcint2);
			SetMemInt(VMCode[IP].dest, srcint1^srcint2);
		}
		IP++;
		break;
	case NOT:
		if (VMCode[IP].op&FLFLAG) {
			VMError(__LINE__, "NOT use float");
		}
		else if (VMCode[IP].op & FLAG1)
			srcint1=VMCode[IP].src1.i;
		else
			srcint1=GetMemInt(VMCode[IP].src1.i);
		SetMemInt(VMCode[IP].dest, ~srcint1);
		IP++;
		break;
/*LOGOR, LOGAND,*/
	case NOTEQU:
		if (VMCode[IP].op&FLFLAG) {
			PrepareFloat(VMCode[IP].op, &srcfloat1, &srcfloat2);
			SetMemInt(VMCode[IP].dest, srcfloat1!=srcfloat2);
		}
		else if (VMCode[IP].op&STRFLAG) {
			srcint1=VMCode[IP].src1.i;
			srcint2=VMCode[IP].src2.i;
			SetMemInt(VMCode[IP].dest, 
				*VMMEM(srcint1).str!=*VMMEM(srcint2).str);
		}
		else {
			PrepareInt(VMCode[IP].op, &srcint1, &srcint2);
			SetMemInt(VMCode[IP].dest, srcint1!=srcint2);
		}
		IP++;
		break;
	case EQU:
		if (VMCode[IP].op&FLFLAG) {
			PrepareFloat(VMCode[IP].op, &srcfloat1, &srcfloat2);
			SetMemInt(VMCode[IP].dest, srcfloat1==srcfloat2);
		}
		else if (VMCode[IP].op&STRFLAG) {
			srcint1=VMCode[IP].src1.i;
			srcint2=VMCode[IP].src2.i;
			SetMemInt(VMCode[IP].dest, 
				*VMMEM(srcint1).str==*VMMEM(srcint2).str);
		}
		else {
			PrepareInt(VMCode[IP].op, &srcint1, &srcint2);
			SetMemInt(VMCode[IP].dest, srcint1==srcint2);
		}
		IP++;
		break;
	case LESS:
		if (VMCode[IP].op&FLFLAG) {
			PrepareFloat(VMCode[IP].op, &srcfloat1, &srcfloat2);
			SetMemInt(VMCode[IP].dest, srcfloat1<srcfloat2);
		}
		else if (VMCode[IP].op&STRFLAG) {
			srcint1=VMCode[IP].src1.i;
			srcint2=VMCode[IP].src2.i;
			SetMemInt(VMCode[IP].dest, 
				*VMMEM(srcint1).str<*VMMEM(srcint2).str);
		}
		else {
			PrepareInt(VMCode[IP].op, &srcint1, &srcint2);
			SetMemInt(VMCode[IP].dest, srcint1<srcint2);
		}
		IP++;
		break;
	case LE:
		if (VMCode[IP].op&FLFLAG) {
			PrepareFloat(VMCode[IP].op, &srcfloat1, &srcfloat2);
			SetMemInt(VMCode[IP].dest, srcfloat1<=srcfloat2);
		}
		else if (VMCode[IP].op&STRFLAG) {
			srcint1=VMCode[IP].src1.i;
			srcint2=VMCode[IP].src2.i;
			SetMemInt(VMCode[IP].dest, 
				*VMMEM(srcint1).str<=*VMMEM(srcint2).str);
		}
		else {
			PrepareInt(VMCode[IP].op, &srcint1, &srcint2);
			SetMemInt(VMCode[IP].dest, srcint1<=srcint2);
		}
		IP++;
		break;
	case GREAT:
		if (VMCode[IP].op&FLFLAG) {
			PrepareFloat(VMCode[IP].op, &srcfloat1, &srcfloat2);
			SetMemInt(VMCode[IP].dest, srcfloat1>srcfloat2);
		}
		else if (VMCode[IP].op&STRFLAG) {
			srcint1=VMCode[IP].src1.i;
			srcint2=VMCode[IP].src2.i;
			SetMemInt(VMCode[IP].dest, 
				*VMMEM(srcint1).str>*VMMEM(srcint2).str);
		}
		else {
			PrepareInt(VMCode[IP].op, &srcint1, &srcint2);
			SetMemInt(VMCode[IP].dest, srcint1>srcint2);
		}
		IP++;
		break;
	case GE:
		if (VMCode[IP].op&FLFLAG) {
			PrepareFloat(VMCode[IP].op, &srcfloat1, &srcfloat2);
			SetMemInt(VMCode[IP].dest, srcfloat1>=srcfloat2);
		}
		else if (VMCode[IP].op&STRFLAG) {
			srcint1=VMCode[IP].src1.i;
			srcint2=VMCode[IP].src2.i;
			SetMemInt(VMCode[IP].dest, 
				*VMMEM(srcint1).str>=*VMMEM(srcint2).str);
		}
		else {
			PrepareInt(VMCode[IP].op, &srcint1, &srcint2);
			SetMemInt(VMCode[IP].dest, srcint1>=srcint2);
		}
		IP++;
		break;
	case PUSH:
		if (VMCode[IP].op & FLAG1)
			if (VMCode[IP].op&FLFLAG)
				SetMemFloat(--SP, VMCode[IP].src1.f);
			else
				SetMemInt(--SP, VMCode[IP].src1.i);
		else MemCopy(VMCode[IP].src1.i, --SP);
		IP++;
		break;
	case POP:
		if (VMCode[IP].op & FLAG3) {
			if (VMCode[IP].op & FLAG1) SP+=VMCode[IP].src1.i;
			else VMError(__LINE__, "VM can't support this");
		}
		else {
			MemCopy(SP, VMCode[IP].dest);
			SP++;
		}
		IP++;
		break;
	case JMP:
		if (VMCode[IP].op & FLAG3) {
			IP=VMCode[IP].dest;
		}
		else IP=GetMemInt(VMCode[IP].dest);
		break;
	case CALL:
		DoCall();
		break;
	case RET:
		return 0;
	case JE:
		if (VMCode[IP].op&FLFLAG) {
			PrepareFloat(VMCode[IP].op, &srcfloat1, &srcfloat2);
			if (srcfloat1==srcfloat2) {
				if (VMCode[IP].op&FLAG3) IP=VMCode[IP].dest;
				else IP=VMMEM(VMCode[IP].dest).i;
			}
			else IP++;
		}
		else if (VMCode[IP].op&STRFLAG) {
			srcint1=VMCode[IP].src1.i;
			srcint2=VMCode[IP].src2.i;
			if (*VMMEM(srcint1).str==*VMMEM(srcint2).str) {
				if (VMCode[IP].op&FLAG3) IP=VMCode[IP].dest;
				else IP=VMMEM(VMCode[IP].dest).i;
			}
			else IP++;
		}
		else {
			PrepareInt(VMCode[IP].op, &srcint1, &srcint2);
			if (srcint1==srcint2) {
				if (VMCode[IP].op&FLAG3) IP=VMCode[IP].dest;
				else IP=VMMEM(VMCode[IP].dest).i;
			}
			else IP++;
		}
		break;
/*  JG,  JL */
	case JNE:
		if (VMCode[IP].op&FLFLAG) {
			PrepareFloat(VMCode[IP].op, &srcfloat1, &srcfloat2);
			if (srcfloat1!=srcfloat2) {
				if (VMCode[IP].op&FLAG3) IP=VMCode[IP].dest;
				else IP=VMMEM(VMCode[IP].dest).i;
			}
			else IP++;
		}
		else if (VMCode[IP].op&STRFLAG) {
			srcint1=VMCode[IP].src1.i;
			srcint2=VMCode[IP].src2.i;
			if (*VMMEM(srcint1).str!=*VMMEM(srcint2).str) {
				if (VMCode[IP].op&FLAG3) IP=VMCode[IP].dest;
				else IP=VMMEM(VMCode[IP].dest).i;
			}
			else IP++;
		}
		else {
			PrepareInt(VMCode[IP].op, &srcint1, &srcint2);
			if (srcint1!=srcint2) {
				if (VMCode[IP].op&FLAG3) IP=VMCode[IP].dest;
				else IP=VMMEM(VMCode[IP].dest).i;
			}
			else IP++;
		}
		break;
	case INC:
		if (VMCode[IP].op&FLFLAG)
			SetMemFloat(VMCode[IP].dest,
						GetMemFloat(VMCode[IP].dest)+1);
		else
			SetMemInt(VMCode[IP].dest,
						GetMemInt(VMCode[IP].dest)+1);
		IP++;
		break;
	case DEC:
		if (VMCode[IP].op&FLFLAG)
			SetMemFloat(VMCode[IP].dest,
						GetMemFloat(VMCode[IP].dest)-1);
		else
			SetMemInt(VMCode[IP].dest,
						GetMemInt(VMCode[IP].dest)-1);
		IP++;
		break;
	case CNV:
		if (VMCode[IP].op&FLFLAG) {
			if (VMCode[IP].op&FLAG1)
				srcfloat1=VMCode[IP].src1.f;
			else srcfloat1=GetMemFloat(VMCode[IP].src1.i);
			SetMemInt(VMCode[IP].dest,(int)srcfloat1);
		}
		else {
			if (VMCode[IP].op&FLAG1)
				srcint1=VMCode[IP].src1.i;
			else srcint1=GetMemInt(VMCode[IP].src1.i);
			SetMemFloat(VMCode[IP].dest,(float)srcint1);
		}
		IP++;
		break;
	default:
		printf ("Instruction %d(0x%X) at 0x%X can't be handled.\n",
			VMCode[IP].op,VMCode[IP].op,IP);
		return 0;
	}
	return 1;
}

void ResetVM()
{
	int i;
	SP=STACKSIZE;
	IP=0;
	for (i=0; i<STACKSIZE; i++) {
		VMStack[i].tag=T_NULL;
		VMMEM(i).str=0;
	}
}

int _matherr( struct _exception *except )
{
	VMError(__LINE__, "Runtime mathlib error");
	return 1;
}

